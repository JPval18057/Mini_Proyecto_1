/*
 * File:   main.c
 * Author: JUAN PABLO
 * DESCRIPTION: ESTE ES EL CÓDIGO QUE CONTROLA EL MASTER
 * CON AYUDA DE LA LIBRERIA DE LCD DE ELECTROSOME
 * Created on 21 de febrero de 2021, 08:37 PM
 */

#define _XTAL_FREQ 8000000

#define RS RD2
#define EN RD3
#define D4 RD4
#define D5 RD5
#define D6 RD6
#define D7 RD7

// PIC16F887 Configuration Bit Settings

// 'C' source line config statements

// CONFIG1
#pragma config FOSC = INTRC_NOCLKOUT// Oscillator Selection bits (INTOSCIO oscillator: I/O function on RA6/OSC2/CLKOUT pin, I/O function on RA7/OSC1/CLKIN)
#pragma config WDTE = OFF       // Watchdog Timer Enable bit (WDT disabled and can be enabled by SWDTEN bit of the WDTCON register)
#pragma config PWRTE = OFF      // Power-up Timer Enable bit (PWRT disabled)
#pragma config MCLRE = OFF      // RE3/MCLR pin function select bit (RE3/MCLR pin function is digital input, MCLR internally tied to VDD)
#pragma config CP = OFF         // Code Protection bit (Program memory code protection is disabled)
#pragma config CPD = OFF        // Data Code Protection bit (Data memory code protection is disabled)
#pragma config BOREN = OFF      // Brown Out Reset Selection bits (BOR disabled)
#pragma config IESO = OFF       // Internal External Switchover bit (Internal/External Switchover mode is disabled)
#pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enabled bit (Fail-Safe Clock Monitor is disabled)
#pragma config LVP = OFF        // Low Voltage Programming Enable bit (RB3 pin has digital I/O, HV on MCLR must be used for programming)

// CONFIG2
#pragma config BOR4V = BOR40V   // Brown-out Reset Selection bit (Brown-out Reset set to 4.0V)
#pragma config WRT = OFF        // Flash Program Memory Self Write Enable bits (Write protection off)

// #pragma config statements should precede project file includes.
// Use project enums instead of #define for ON and OFF.

//INCLUIR LIBRERIAS
#include <xc.h>
#include <stdio.h>
#include <pic16f887.h> //se necesita para usar sprintf y formatear strings
#include "lcd.h"
#include "spi.h"

//PROTOTIPOS DE FUNCION
void rutine(void);
//static void spiReceiveWait(void);

//Variables
unsigned char recibo = 0;
char s[20];

//INTERRUPCIONES
void __interrupt() ISR(void) {
    //Revisar si se recibió algún dato
    if (PIR1bits.SSPIF){
        //spiReceiveWait();
        recibo = SSPBUF; //leemos el dato rápidamente
        PIR1bits.SSPIF = 0; //APAGAMOS LA BANDERA
    }
    
}

//CONFIGURACION GENERAL
void setup(){
    //CONFIGURACION DE I/O
    TRISD = 0; //PUERTO D COMO SALIDA
    TRISD = 0; //PUERTO C COMO SALIDA
    TRISB = 0; //PUERTO B COMO SALIDA PARA PRUEBAS
    
    //CONFIGURACION DE RELOJ
    OSCCON = 0b01110101; //RELOJ INTERNO A 8MHZ
    //CONFIGURACION DE SPI
    /*PINES
     RA5 -> SLAVE SELECT
     SERIAL CLOCK -> RC3 
     SERIAL DATA OUT (SDO) -> RC5 MASTER OUT SLAVE IN/ SACA DATOS DEL ESCLAVO
     SERIAL DATA IN (SDI)-> RC4 SLAVE IN MASTER OUT/ ENTRAN DATOS DEL MAESTRO
     
    */
    TRISCbits.TRISC0 = 0; //SS botones
    TRISCbits.TRISC1 = 0; //SS adc
    TRISCbits.TRISC2 = 0; //SS temp
    PORTCbits.RC0 = 1;
    PORTCbits.RC1 = 1;
    PORTCbits.RC2 = 1; //apagamos todos los slaves por default
    
    TRISCbits.TRISC3 = 0; //MASTER MODE SCK COMO SALIDA
    TRISCbits.TRISC5 = 0; //SERIAL DATA OUT como entrada porque este es el maestro
    TRISAbits.TRISA5 = 1; //SLAVE SELECT como entrada
    //INICIALIZACION DEL MODULO SPI
    //spiInit(SPI_MASTER_OSC_DIV4, SPI_DATA_SAMPLE_MIDDLE, SPI_CLOCK_IDLE_LOW, SPI_IDLE_2_ACTIVE);
    PORTB = 0;
    //CONFIGURACION DE INTERRUPCIONES
    ei();//global interrupt enable
    INTCONbits.PEIE = 1; //PERIPHERAL INTERRUPT ENABLE
    PIE1bits.SSPIE = 1; //activar interrupcion de SPI
    PIR1bits.SSPIF = 0;//apagar la bandera
    //CONFIGURACION DE PANTALLA
    Lcd_Init();
    
    //Pruebas de codigo
    
    return;
}


//CODIGO PRINCIPAL
void main(void) {
    //esta parte solo se ejecuta 1 vez
    setup();
    //esta parte se ejecuta continuamente
    while(1){
        //Rutina de comunicación
        rutine();
        Lcd_Clear(); //limpia la pantalla
        Lcd_Set_Cursor(1,1); //poner el cursor en fila 1 caracter 1
        Lcd_Write_String("TEM POT CONT");
        Lcd_Set_Cursor(2,1);
        sprintf(s,"%u",0);
        Lcd_Write_Char(s[0]);//escribimos el dato que se recibio
        PORTB = recibo;
        __delay_ms(500); //para que se aprecie en la simulación        
        
    }
    return;
}

void rutine(void){
    PORTCbits.RC0 = 1; //APAGAR BOTONES
    PORTCbits.RC2 = 1; //APAGAR TEMP
    PORTCbits.RC1 = 0; //SELECCIONAR ADC
     //__delay_ms(1);
    recibo = spiRead();
    PORTCbits.RC1 = 1; //APAGAR ESCLAVO ADC
     
    return;
}
